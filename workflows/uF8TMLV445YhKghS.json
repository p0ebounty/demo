{
  "id": "uF8TMLV445YhKghS",
  "name": "Parsing parameters",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "cs_id",
              "type": "number"
            },
            {
              "name": "call_id",
              "type": "number"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1744,
        240
      ],
      "id": "0b1d00f4-88c3-41e8-93d1-5659de8e121e",
      "name": "start"
    },
    {
      "parameters": {
        "authentication": "nocoDbApiToken",
        "workspaceId": "wqp6q0zt",
        "projectId": "p0a3eirwme1bmw7",
        "table": "mq8zrzuevo96lmw",
        "id": "={{ $node[\"start\"].json[\"call_id\"] }}"
      },
      "type": "n8n-nodes-base.nocoDb",
      "typeVersion": 3,
      "position": [
        -1296,
        240
      ],
      "id": "f7ab351c-ceba-407f-b77f-7a9be0283e36",
      "name": "get call",
      "credentials": {
        "nocoDbApiToken": {
          "id": "tg1sd8Mux2yjJLx7",
          "name": "NocoDB"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $node[\"get call\"].json[\"Transcript\"] || \"-\" }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=You are a specialized parser agent called **Loads Week Extractor**.\n\nYou are analyzing a **phone conversation transcript** structured as alternating lines between the human user and the AI voice agent, formatted like this:\nUser: ...\nAI: ...\nUser: ...\nAI: ...\n\nImportant:\n- Only analyze and extract information from the **User:** lines (the human client).  \n- Completely ignore anything said by the AI.  \n- Never use statements from the AI as evidence or context for your extraction.\n\n**CRITICAL: Distinguish between clarifying questions vs memory recap:**\n\n**DO extract when User confirms a clarifying question:**\n- AI: \"So 15 loads per week?\" User: \"Yes\" → extract 15 ✅\n- AI: \"Is it around 20?\" User: \"Yeah\" → extract 20 ✅\n- AI: \"You handle 10 weekly?\" User: \"Correct\" → extract 10 ✅\n\n**DON'T extract when User confirms AI recapping from memory:**\n- AI: \"You MENTIONED 20 loads\" User: \"Yeah\" → return null ❌\n- AI: \"LAST TIME you said 15\" User: \"Yes\" → return null ❌\n- User: \"We discussed this last call\" → return null ❌\n\nKey indicators AI is recapping from memory:\n- \"you mentioned\", \"you said\", \"last time\", \"previously\", \"earlier you told me\"\n\nIf User just confirms without AI using memory language → extract the number\n\n---\n\nYour goal: extract the average number of shipments (loads) a client handles **per week** based solely on what the **User** says.\n\nFollow these precise rules:\n\n1. Your output must be a single JSON object:\n   \n   {\"loads_per_week\": <number or null>}\n\n2. Look only for numeric information about shipment frequency in the **User**’s speech.\n\n3. If the client gives a **weekly** number (e.g. “8 per week”, “10 weekly”) — return that number directly.\n\n4. If they mention another period, convert it to **per week** using the n8n \"calculator\" tool:\n\n   * per day → multiply by 7  \n   * per week → multiply by 1  \n   * per month → divide by 4  \n   * per quarter → divide by 13  \n   * per year → divide by 52  \n\n   Example:\n   * “20 per month” → \"20 / 4 = 5\"\n   * “30 per quarter” → \"30 / 13 = 2.31\"\n   * “1 per month” → \"1 / 4 = 0.25\"\n\n5. If the client gives a **range** (e.g. “10–15 per week”), take the average: \"(10 + 15) / 2 = 12.5\".\n\n6. If the number is approximate (“around 20”, “about a dozen”, “a couple”), interpret as:\n\n   * couple → 2  \n   * few → 3  \n   * several → 4  \n   * dozen → 12\n\n7. If there is **no numeric info**, output:\n   \n   {\"loads_per_week\": null}\n\n8. If multiple numbers are mentioned, choose the one that clearly refers to **shipping or load frequency**.\n\n9. Always normalize the result to a numeric value (use a dot for decimals, e.g. \"0.25\").\n\n10. Do not output anything except the final JSON object.\n\n---\n\n### Examples (analyzing only User lines)\n\n* User: “We move 8–10 loads per week.” → {\"loads_per_week\": 9}\n* User: “About 20 per month.” → {\"loads_per_week\": 5}\n* User: “Roughly 1 per month.” → {\"loads_per_week\": 0.25}\n* User: “Two per day.” → {\"loads_per_week\": 14}\n* User: “30 per quarter.” → {\"loads_per_week\": 2.31}\n* User: “52 per year.” → {\"loads_per_week\": 1}\n* User: \"Couple a week.\" → {\"loads_per_week\": 2}\n* User: \"Depends, varies.\" → {\"loads_per_week\": null}\n\n### Positive examples (DO extract - clarifying questions):\n\n* AI: \"So 15 loads per week?\" User: \"Yes.\" → {\"loads_per_week\": 15}\n* AI: \"Around 20 weekly?\" User: \"Yeah, correct.\" → {\"loads_per_week\": 20}\n* AI: \"You handle 10 per week?\" User: \"Yep.\" → {\"loads_per_week\": 10}\n\n### Negative examples (DO NOT extract - memory recap):\n\n* AI: \"You MENTIONED 20 loads per week.\" User: \"Yeah.\" → {\"loads_per_week\": null}\n* AI: \"LAST TIME you said 30 per month.\" User: \"Yes, correct.\" → {\"loads_per_week\": null}\n* User: \"We already discussed this last call.\" → {\"loads_per_week\": null}\n* AI: \"PREVIOUSLY you told me 15 weekly.\" User: \"Mhm.\" → {\"loads_per_week\": null}\n\nRemember: extract only the weekly load count from the **User's speech** when they EXPLICITLY STATE it in THIS conversation — never from AI's recap or simple confirmations."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -544,
        -368
      ],
      "id": "32e8c00f-4fe1-4dc4-9903-4fb31c4c477f",
      "name": "loads_per_week",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolCalculator",
      "typeVersion": 1,
      "position": [
        -1072,
        -880
      ],
      "id": "c8e5076f-25e8-457d-8dfc-9df69c4a2583",
      "name": "Calculator"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $node[\"get call\"].json[\"Transcript\"] || \"-\" }}",
        "options": {
          "systemMessage": "=You are a specialized parser called **Interest Level Classifier**.  \nYou are analyzing a **phone conversation transcript** between a user and a City Company sales AI agent, structured as alternating lines:  \nUser: ...  \nAI: ...  \nUser: ...  \nAI: ...  \n\n**Important**:\n- Only analyze and classify based on what the **User** says.  \n- Completely ignore any statements, offers, or phrases spoken by the AI.  \n- The AI's words should never influence the decision about interest level.\n\n---\n\nYour task: determine the client's level of interest in cooperation with City Company (freight/logistics services), based solely on the concrete business intent of the **User's** speech.\n\nReturn only one of the following exact values (case-sensitive):\n- **No interest**  \n- **Low**  \n- **Medium**  \n- **Hot**  \n- *(return empty string if no clear interest level can be determined)*\n\n---\n\n### Rules:\n\n- **No interest** — the user clearly expresses no interest or refusal to cooperate.  \n  Examples: \"Not interested\", \"We're all set with carriers\", \"Remove us from your list\", \"Don't call again\", \"We're not looking for new carriers.\"  \n\n- **Low** — the user responds briefly or reluctantly with minimal concrete engagement.  \n  They do not refuse but show little business intent or action.  \n  Examples: \"Maybe\", \"Not sure\", \"You can send info\", \"We'll see\", \"Send me something and we'll look at it.\"\n\n- **Medium** — the user provides concrete responses, agrees to specific actions, or engages in meaningful discussion about their logistics needs.  \n  Shows willingness to continue dialogue or test services.  \n  Examples: \"We can test later\", \"Call back next month\", \"Send your info and rates\", \"We handle about 50 shipments weekly\", \"What are your rates for Midwest to East Coast?\", \"Our next RFP is in Q2.\"\n\n- **Hot** — the user shows strong concrete interest with specific business questions, shares detailed operational info, or indicates readiness to cooperate.  \n  Actively engages with questions about rates, lanes, equipment, timelines, or next steps.  \n  Examples: \"Send your rates for our main lanes\", \"When can you start?\", \"What's your capacity for reefer shipments?\", \"We need backup carriers for West Coast\", \"Can you handle 10 truckloads per week?\", \"Let's set up a pilot shipment.\"\n\n- Return nothing if the user's speech does not provide enough concrete information to determine interest level.  \n  For example, when the user says things like \"Sorry, I’m busy\" or \"Please call back later\" without giving any relevant business information.\n\n---\n\n### Guidelines:\n\n1. **Focus only on User lines** for tone and intent.\n\n2. **Analyze the trajectory of interest throughout the conversation:**\n   - If the user starts cold but warms up → classify based on the final state.\n   - If the user starts interested but becomes disengaged → classify based on the final state.\n   - The ending sentiment and concrete actions agreed upon matter most.\n   - If user initially says \"not interested\" but then asks questions about services → trajectory shows warming up.\n\n3. **Only analyze topics initiated by the AI agent (logistics/freight/shipping):**\n   - If the user tries to change the subject or goes off-topic → ignore those statements.\n   - Only consider user responses directly related to freight, logistics, carriers, shipping, lanes, equipment, rates, or transportation services.\n   - Off-topic diversions (weather, personal chat, unrelated business) do not affect classification.\n\n4. **Ignore politeness, pleasantries, and social niceties:**\n   - \"Thank you\", \"Have a nice day\", \"Sorry I'm busy\", \"You're very kind\" → these don't indicate interest level.\n   - Focus only on concrete business statements: agreement to receive info, questions about services, sharing operational details, willingness to test/discuss.\n   - A polite \"no thanks\" is still \"No interest\".\n   - A brief \"send your rates\" is \"Hot\" regardless of tone.\n\n5. **Concrete business indicators to look for:**\n   - Sharing shipment volumes → Medium or Hot\n   - Asking about specific services (reefer, LTL, cross-border) → Medium or Hot\n   - Requesting rates or quotes → Hot\n   - Mentioning pain points with current carriers → Medium or Hot\n   - Agreeing to follow-up call or proposal → Medium\n   - Sharing email for documents → Medium\n   - Discussing lanes, equipment types, or operational details → Medium or Hot\n\n6. **Choose only one category** that best reflects the user's final business intent.\n\n7. **If mixed signals appear**, choose based on **trajectory and final concrete outcome**:\n   - Did they agree to something specific? → Medium or Hot\n   - Did they ask for business details or rates? → Hot\n   - Did they share operational info? → Medium or Hot\n   - Did they remain vague throughout? → Low\n   - Did they refuse or disengage? → No interest\n   - Did they give no actionable response? → *(return empty)*\n\n8. **Do not add explanations or reasoning** — return only the single label."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -544,
        0
      ],
      "id": "022737a1-30d6-4c45-8352-3e7d11fed912",
      "name": "interest_level",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"Loads Week Parser Output\",\n  \"description\": \"Schema for extracting the average number of shipments (loads) per week from client responses.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"loads_per_week\": {\n      \"type\": [\"number\", \"null\"],\n      \"description\": \"Average number of shipments per week. If client mentions another period, the value is converted to weekly equivalent (e.g. 20 per month → 5 per week). If no numeric info was provided, return null.\",\n      \"examples\": [9, 5, 0.25, 2.31, 12.5, null]\n    }\n  },\n  \"required\": [\"loads_per_week\"],\n  \"additionalProperties\": false\n}\n",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -560,
        -160
      ],
      "id": "149e8dfb-3554-478e-a7ee-8f6062e29814",
      "name": "loads_per_week parser"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $node[\"get call\"].json[\"Transcript\"] || \"-\" }}",
        "options": {
          "systemMessage": "=You are a specialized parser called **Shipping Directions Extractor**.\n\nYou are analyzing a **phone conversation transcript** structured as alternating lines between the human user and the AI voice agent, formatted like this:\nUser: ...\nAI: ...\nUser: ...\nAI: ...\n\n⚠️ Important:\n- Analyze **only** what the **User** says.  \n- Completely ignore any regions, routes, or trade terms mentioned by the AI.  \n- The AI's words must never trigger or influence tag selection.\n\n**CRITICAL: Distinguish between clarifying questions vs memory recap:**\n\n**DO extract when User confirms a clarifying question:**\n- AI: \"So you ship to Canada?\" User: \"Yes\" → extract Canada ✅\n- AI: \"US and Mexico?\" User: \"Yeah\" → extract US,Mexico ✅\n- AI: \"Florida to Illinois?\" User: \"Correct\" → extract US ✅\n\n**DON'T extract when User confirms AI recapping from memory:**\n- AI: \"You MENTIONED Canada\" User: \"Yeah\" → return empty ❌\n- AI: \"LAST TIME you said Florida to Illinois\" User: \"Yes\" → return empty ❌\n- User: \"We discussed this last call\" → return empty ❌\n\nKey indicators AI is recapping from memory:\n- \"you mentioned\", \"you said\", \"last time\", \"previously\", \"earlier you told me\"\n\nIf User just confirms without AI using memory language → extract the destinations\n\n---\n\nYour task: identify which shipping directions or regions are mentioned by the **User**.\n\nReturn only a plain text list of tags separated by commas — nothing else.  \nExample outputs:  \nUS,Canada  \nAsia,EU,Export  \nCanada,Import\n\n---\n\n### Allowed tags (use exact spelling and capitalization):\n- Canada  \n- US  \n- EU  \n- Asia  \n- Import  \n- Export\n\n---\n\n### Rules:\n- Include a tag if the **User** clearly mentions or implies that region or trade direction.  \n- “Canada”, “US”, “EU”, “Asia” → based on geography, country names, or regional terms.  \n- “Import” → if the **User** talks about receiving goods from abroad.  \n- “Export” → if the **User** talks about shipping goods abroad.  \n- If multiple apply, separate them with commas (no spaces before or after commas).  \n- Sort tags alphabetically for consistency (e.g. \"Asia,Canada,Export\").  \n- If no direction is mentioned by the user, return an empty string.\n\n---\n\n### Examples (analyzing only User lines):\n\nUser: \"We move freight between US and Canada.\" → Canada,US  \nUser: \"We import from China and export to Germany.\" → Asia,EU,Export,Import  \nUser: \"We do domestic shipping in the US.\" → US  \nUser: \"We handle Europe and Asia routes.\" → Asia,EU,Export  \nUser: \"No region mentioned.\" → *(return empty)*\n\n### Positive examples (DO extract - clarifying questions):\n\n* AI: \"So Canada and Mexico?\" User: \"Yeah.\" → Canada,US\n* AI: \"You ship to US?\" User: \"Yes.\" → US\n* AI: \"Cross border - Canada, right?\" User: \"Correct.\" → Canada\n\n### Negative examples (DO NOT extract - memory recap):\n\n* AI: \"You MENTIONED Canada and Mexico.\" User: \"Yeah.\" → (return empty string)\n* AI: \"LAST TIME you said Florida to Illinois.\" User: \"Correct.\" → (return empty string)\n* User: \"We talked about this last hour.\" → (return empty string)\n* AI: \"PREVIOUSLY you told me Canada, US.\" User: \"Yep.\" → (return empty string)"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -544,
        224
      ],
      "id": "e4fd6c14-acdf-48c7-9cea-d5c492f5ce05",
      "name": "destinations",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $node[\"get call\"].json[\"Transcript\"] || \"-\" }}",
        "options": {
          "systemMessage": "=You are a specialized parser called **Freight Organization Extractor**.\n\nYou are analyzing a **phone conversation transcript** structured as alternating lines between the human user and the AI voice agent, formatted like this:\nUser: ...\nAI: ...\nUser: ...\nAI: ...\n\n⚠️ Important:\n- Analyze **only** what the **User** says.  \n- Ignore all statements, assumptions, or examples mentioned by the AI.  \n- The AI's questions or summaries must never trigger or influence tag selection.\n\n**CRITICAL: Distinguish between clarifying questions vs memory recap:**\n\n**DO extract when User confirms a clarifying question:**\n- AI: \"Do you have contracts?\" User: \"Yes\" → extract Contract ✅\n- AI: \"Regular lanes?\" User: \"Yeah\" → extract Constant Lanes ✅\n\n**DON'T extract when User confirms AI recapping from memory:**\n- AI: \"You MENTIONED contracts\" User: \"Yeah\" → return empty ❌\n- AI: \"LAST TIME you said regular lanes\" User: \"Yes\" → return empty ❌\n- User: \"We discussed this already\" → return empty ❌\n\nKey indicators AI is recapping from memory:\n- \"you mentioned\", \"you said\", \"last time\", \"previously\", \"earlier you told me\"\n\nIf User just confirms without AI using memory language → extract the tags\n\n---\n\n### Task:\nIdentify how the client organizes their freight operations and return tags as a comma-separated string.\n\nReturn only these exact tags (case-sensitive), separated by commas, alphabetically sorted:\n- Occasional  \n- Contract  \n- Constant Lanes\n\n---\n\n### Rules & cues (based on the User’s speech only):\n\n- **Occasional** — irregular or on-demand shipping.  \n  Cues: “occasionally”, “as needed”, “ad hoc”, “rarely”, “few times a month”, “sporadic”, “we ship only when we have orders”.\n\n- **Contract** — the company has contract shipments or fixed agreements with carriers.  \n  Cues: “under contract”, “contracted carriers”, “rate agreement”, “annual agreement”, “fixed partner”.\n\n- **Constant Lanes** — regular, predictable routes or dedicated lanes.  \n  Cues: “regular lanes”, “same lanes weekly”, “dedicated routes”, “fixed lanes”, “we move from X to Y every week”.\n\n---\n\n### Guidelines:\n- Multiple tags may apply; include all that are clearly supported by the **User**’s statements.\n- Do not infer or assume — only tag what’s explicitly or obviously stated by the User.\n- If nothing relevant is mentioned → return an empty string.\n- Output only the tag list, no extra words, no spaces around commas.\n- Sort alphabetically if multiple tags are selected.\n\n---\n\n### Examples (analyzing only User lines):\n\nUser: “Mostly ad hoc moves when needed.” → Occasional  \nUser: “We have annual rate agreements with a few carriers.” → Contract  \nUser: “Dedicated weekly runs between Chicago and Dallas.” → Constant Lanes  \nUser: “We work with fixed partners and run the same routes each week.” → Contract,Constant Lanes  \nUser: “Can’t say, varies.” → *(return empty)*"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -544,
        832
      ],
      "id": "ae9f4b9a-61bf-41ef-829b-13e343270d22",
      "name": "freight_org",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a2032077-20c2-484c-81bb-ddc648ec13fd",
              "leftValue": "={{ $node[\"get call\"].json[\"Transcript\"] && $node[\"get call\"].json[\"Transcript\"].split(/\\s+/).filter(word => word.trim().length > 0).length > 100 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "697c377b-70e8-4b4b-b4dd-0a5d86ef1e7e",
              "leftValue": "={{ Number($node[\"get call\"].json[\"Duration\"]) > 25 }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "7b927f81-c10b-43d3-9bdc-c5326025261b",
              "leftValue": "={{ $json.Quality }}",
              "rightValue": 1,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1072,
        240
      ],
      "id": "577f6a36-c9c1-4be6-87b6-d43d6a4383a9",
      "name": "run?",
      "disabled": true
    },
    {
      "parameters": {
        "authentication": "nocoDbApiToken",
        "workspaceId": "wqp6q0zt",
        "projectId": "p0a3eirwme1bmw7",
        "table": "mkbhjd0aqdl1r1m",
        "id": "={{ $node[\"start\"].json[\"cs_id\"] }}"
      },
      "type": "n8n-nodes-base.nocoDb",
      "typeVersion": 3,
      "position": [
        -1520,
        240
      ],
      "id": "eb3fa455-cb7b-4057-936b-b11046037922",
      "name": "get cs",
      "credentials": {
        "nocoDbApiToken": {
          "id": "tg1sd8Mux2yjJLx7",
          "name": "NocoDB"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $node[\"get call\"].json[\"Transcript\"] || \"-\" }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=Current date: {{ \"[\" + ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][$now.weekday % 7] + \"] \" + $now.toFormat(\"yyyy-MM-dd\") }}\n\nYou are a specialized parser called **Tender Extractor**.\n\nYou are analyzing a **phone conversation transcript** structured as alternating lines between the human user and the AI voice agent, formatted like this:\nUser: ...\nAI: ...\nUser: ...\nAI: ...\n\nImportant:\n- Analyze **only** what the **User** says.  \n- Ignore any mentions or assumptions made by the AI.  \n- The AI's questions or statements must never influence detection, notes, or extracted dates.\n\n**CRITICAL: Distinguish between clarifying questions vs memory recap:**\n\n**DO extract when User confirms a clarifying question:**\n- AI: \"Your tender is in March?\" User: \"Yes\" → extract March ✅\n- AI: \"So bidding opens in Q1?\" User: \"Yeah\" → extract Q1 dates ✅\n\n**DON'T extract when User confirms AI recapping from memory:**\n- AI: \"You MENTIONED March tender\" User: \"Yeah\" → return null ❌\n- AI: \"LAST TIME you said Q1 bidding\" User: \"Yes\" → return null ❌\n- User: \"We discussed this last call\" → return null ❌\n\nKey indicators AI is recapping from memory:\n- \"you mentioned\", \"you said\", \"last time\", \"previously\", \"earlier you told me\"\n\nIf User just confirms without AI using memory language → extract the information\n\n---\n\n### Goal:\nExtract tender-related information from the conversation and return a single JSON object with four fields:\n\n- **detect** — boolean (`true` if a tender is detected, `false` if not).  \n- **Note** — a short bullet list of key tender facts, or `null` if not applicable.  \n- **Start** — tender start/opening date in `YYYY-MM-DD` (string) or `null` if not mentioned.  \n- **End** — tender end/close/submission deadline date in `YYYY-MM-DD` (string) or `null` if not mentioned.\n\nReturn **only the JSON object**, no extra text.\n\n---\n\n### JSON structure\n\n{\n  \"detect\": true,\n  \"Note\": \"<bullet list with '• ' bullets, each on a new line or null>\",\n  \"Start\": \"<YYYY-MM-DD or null>\",\n  \"End\": \"<YYYY-MM-DD or null>\"\n}\n\n---\n\n### Detection rules for **detect**\n\nSet `\"detect\": true` **only if the User’s lines** clearly or implicitly refer to a tender, RFP, RFQ, bid, or procurement process.\n\nTrigger if the user mentions:\n- submission deadlines, awards, lane files, or structured carrier selection;\n- or uses any of the following keywords:  \n  `RFP`, `RFQ`, `tender`, `bid`, `bidding`, `procurement`, `RFI`, `award`, `allocate`, `vendor list`, `lane file`, `submission`, `deadline`, `portal`, `evaluation`, `award date`.\n\nIf the user never mentions these or related concepts →  \n`\"detect\": false` and all other fields (`Note`, `Start`, `End`) = `null`.\n\n---\n\n### What to include in **Note**\n\nIf `\"detect\": true`, build a concise bullet list using the prefix `• ` on each line.  \nEach line = one fact from the **User’s** speech. Include relevant details such as:\n\n* Stage or timing (planned, open, evaluating, awarded, go-live)\n* Scope or lane count (“12 lanes”, “20–25 lanes”)\n* Required documents (COI, authority, NDA, packet)\n* Submission process (portal, lane file, email)\n* Evaluation or award details (allocation %, incumbents)\n* Any additional info about deadlines, services, or coverage\n\nIf no tender is detected → `Note: null`.\n\n---\n\n### Date extraction & normalization\n\n**Format:** `YYYY-MM-DD` (always as string)\n\nIf a specific date is mentioned → normalize to `YYYY-MM-DD`.  \nIf only a month/year → use day `01` (e.g., \"March 2025\" → `2025-03-01`).  \nIf a quarter → use quarter start (`Q1=01-01`, `Q2=04-01`, `Q3=07-01`, `Q4=10-01`).  \nIf \"mid-month\" → use day `15`.  \nIf \"week of <date>\" → use that date as start of the week.  \nIf relative (\"next Friday\", \"in two weeks\") → interpret relative to **Current date** above.  \nIf only one deadline date is mentioned → set as **End**, leave **Start = null**.  \nIf both opening and closing dates are mentioned → earlier → **Start**, later → **End**.  \nIf no date-like information → both `null`.\n\n**Start cues:** \"opens\", \"start\", \"launch\", \"go-live\", \"submission window begins\"  \n**End cues:** \"deadline\", \"due by\", \"closes\", \"cutoff\", \"submission ends\"  \nDates referring to *award* or *evaluation* belong in **Note**, not **Start/End**.\n\n---\n\n**CRITICAL DATE VALIDATION RULES:**\n\n1. **If Start > End after extraction** → Set `Start = null` (do not guess, safer to omit incorrect date).\n\n2. **If End date is in the PAST** (before Current date):\n   - If User mentioned a specific year → keep as-is (historical tender).\n   - If NO year mentioned (e.g., \"March 15\") → assume NEXT occurrence of that date.\n   - Example: Current date = Nov 6, 2025, User says \"deadline March 15\" → End = `2026-03-15`.\n\n3. **If Start date is in the PAST** (before Current date):\n   - If User mentioned a specific year → keep as-is (historical tender).\n   - If NO year mentioned (e.g., \"opens in April\") → assume NEXT occurrence of that month/date.\n   - Example: Current date = Nov 6, 2025, User says \"launching April\" → Start = `2026-04-01`.\n\n4. **If relative date + absolute date create conflict**:\n   - Prioritize the **absolute date** (e.g., \"March 15th\").\n   - Set relative date (e.g., \"next Monday\") = `null` if it creates Start > End.\n   - Add context to **Note** if needed (e.g., \"Opening mentioned as 'next Monday' but conflicts with stated deadline\").\n\n5. **Logic check before output**:\n   - If Start exists and End exists → Start MUST be ≤ End.\n   - If this fails → set Start = null.\n\n---\n\n### Examples (analyzing only User lines)\n\n**Example 1**\nUser: “We’re opening the RFP on March 1st, 2025 and closing submissions March 20. 12 lanes. Need COI and authority. Award by April.”\n→\n{\n  \"detect\": true,\n  \"Note\": \"• 12 lanes\\n• Docs: COI, authority\\n• Award by April\\n• RFP window stated\",\n  \"Start\": \"2025-03-01\",\n  \"End\": \"2025-03-20\"\n}\n\n---\n\n**Example 2**\nUser: “Submission deadline is Aug 15, 2025. Lane file will be shared next week.”\n→\n{\n  \"detect\": true,\n  \"Note\": \"• Lane file provided\\n• Submission deadline stated\",\n  \"Start\": null,\n  \"End\": \"2025-08-15\"\n}\n\n---\n\n**Example 3**\nUser: “Planned tender in Q2 2025, scope 20–25 lanes, requires NDA.”\n→\n{\n  \"detect\": true,\n  \"Note\": \"• Planned in Q2 2025\\n• Scope: 20–25 lanes\\n• Requires NDA\",\n  \"Start\": \"2025-04-01\",\n  \"End\": null\n}\n\n---\n\n**Example 4**\nUser: “No tender planned.”\n→\n{\n  \"detect\": false,\n  \"Note\": null,\n  \"Start\": null,\n  \"End\": null\n}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        -544,
        448
      ],
      "id": "7506111b-2444-4aa4-9b41-68cbc465f328",
      "name": "tender_detect",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"Tender Extractor Output\",\n  \"description\": \"Schema for extracting tender-related information from conversation transcripts.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"detect\": {\n      \"type\": \"boolean\",\n      \"description\": \"True if a tender or RFP/RFQ process is detected in the conversation; false otherwise.\",\n      \"examples\": [true, false]\n    },\n    \"Note\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"Bullet list of key tender facts, each line starting with '• '. Null if no tender detected.\",\n      \"examples\": [\n        \"• 12 lanes\\n• Docs: COI, authority\\n• Award by April\",\n        null\n      ]\n    },\n    \"Start\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"Tender start/open date in YYYY-MM-DD format, or null if not mentioned.\",\n      \"pattern\": \"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\",\n      \"examples\": [\"2025-03-01\", null]\n    },\n    \"End\": {\n      \"type\": [\"string\", \"null\"],\n      \"description\": \"Tender end/close/submission deadline in YYYY-MM-DD format, or null if not mentioned.\",\n      \"pattern\": \"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\",\n      \"examples\": [\"2025-03-20\", null]\n    }\n  },\n  \"required\": [\"detect\", \"Note\", \"Start\", \"End\"],\n  \"additionalProperties\": false\n}\n",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -544,
        672
      ],
      "id": "ca4c42cf-651f-4581-ba2d-b0f5268b5f57",
      "name": "tender_detect parser"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1.1,
      "position": [
        -1072,
        -560
      ],
      "id": "c441ea82-8168-459c-8ccf-e3de79b699ce",
      "name": "Think"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1072,
        -720
      ],
      "id": "d6a345e5-36eb-4931-92d8-63183182a9c3",
      "name": "4.1-mini",
      "credentials": {
        "openAiApi": {
          "id": "895vd8bC2qxU4JL4",
          "name": "OpenAi"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1",
          "mode": "list",
          "cachedResultName": "gpt-4.1"
        },
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1072,
        -384
      ],
      "id": "29d69d25-798b-4d5e-a34c-2dcce278aa81",
      "name": "4.1",
      "credentials": {
        "openAiApi": {
          "id": "895vd8bC2qxU4JL4",
          "name": "OpenAi"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -16,
        176
      ],
      "id": "3bd00b7f-8983-46d3-ba29-8029490a92e9",
      "name": "Merge"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        192,
        224
      ],
      "id": "365cb6b4-db12-48f4-b956-c85e6813f98d",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "authentication": "nocoDbApiToken",
        "operation": "update",
        "workspaceId": "wqp6q0zt",
        "projectId": "p0a3eirwme1bmw7",
        "table": "mkbhjd0aqdl1r1m",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldName": "Id",
              "fieldValue": "={{ $('start').item.json.cs_id }}"
            },
            {
              "fieldName": "Loads Week",
              "fieldValue": "={{ $json.loads_per_week }}"
            },
            {
              "fieldName": "Interest",
              "fieldValue": "={{ $json.interest_level }}"
            },
            {
              "fieldName": "Destinations",
              "fieldValue": "={{ $json.destinations }}"
            },
            {
              "fieldName": "Freight Org",
              "fieldValue": "={{ $json.freight_org }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.nocoDb",
      "typeVersion": 3,
      "position": [
        624,
        224
      ],
      "id": "ebcc017b-19fa-4482-b487-99d8e7328f60",
      "name": "update parameters",
      "credentials": {
        "nocoDbApiToken": {
          "id": "tg1sd8Mux2yjJLx7",
          "name": "NocoDB"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "5cfa914c-5fe3-4b3e-b15e-f36a270da736",
              "name": "loads_per_week",
              "value": "={{ $json[''][0].output.loads_per_week ?? $('get cs').item.json['Loads Week'] ?? null }}",
              "type": "number"
            },
            {
              "id": "516b8f66-6841-477f-b3ea-c70ea8646b01",
              "name": "interest_level",
              "value": "={{ $json[''][1].output || $('get cs').item.json['Interest'] || 'No interest' }}",
              "type": "string"
            },
            {
              "id": "692f015f-af3d-4cd4-9259-227641a20749",
              "name": "destinations",
              "value": "={{\n(() => {\n  const existing = (($('get cs').item.json['Destinations'] ?? '') + '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean)\n  const incoming = (($json[''][2].output ?? '') + '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean)\n  const result = [...existing, ...incoming].removeDuplicates().join(',')\n  return result || null\n})()\n}}",
              "type": "string"
            },
            {
              "id": "550bd5cf-31a5-47fe-bf7a-78fbe0463016",
              "name": "tender_detect",
              "value": "={{ $json[''][3].output || null }}",
              "type": "object"
            },
            {
              "id": "87bc4a43-830a-4e76-bc7d-19b79c751c58",
              "name": "freight_org",
              "value": "={{\n(() => {\n  const existing = (($('get cs').item.json['Freight Org'] ?? '') + '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean)\n  const incoming = (($json[''][4].output ?? '') + '')\n    .split(',')\n    .map(s => s.trim())\n    .filter(Boolean)\n  if ($json.tender_detect?.detect === true) incoming.push('Tender')\n  const result = [...existing, ...incoming].removeDuplicates().join(',')\n  return result || null\n})()\n}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        416,
        224
      ],
      "id": "225a82b8-6824-44bd-8baf-efb66f847b9f",
      "name": "to beauty"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "3fa7f424-942c-4ff6-88c0-9c0976cd19a8",
              "leftValue": "={{ $('get cs').item.json.Tender.Id }}",
              "rightValue": "",
              "operator": {
                "type": "number",
                "operation": "empty",
                "singleValue": true
              }
            },
            {
              "id": "794380af-8c0a-4f61-9698-bcae12e04fec",
              "leftValue": "={{ $json.tender_detect.detect }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        624,
        -64
      ],
      "id": "e54c8a82-cd63-48f1-a7dc-017a17a23f26",
      "name": "create tender?"
    },
    {
      "parameters": {
        "authentication": "nocoDbApiToken",
        "operation": "create",
        "workspaceId": "wqp6q0zt",
        "projectId": "p0a3eirwme1bmw7",
        "table": "m72mqad09x2x46l",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldName": "Note",
              "fieldValue": "={{ $json.tender_detect.Note }}"
            },
            {
              "fieldName": "Start",
              "fieldValue": "={{ $json.tender_detect.Start }}"
            },
            {
              "fieldName": "End",
              "fieldValue": "={{ $json.tender_detect.End }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.nocoDb",
      "typeVersion": 3,
      "position": [
        848,
        -64
      ],
      "id": "a395a1b5-b0dc-4cbe-9e30-7da0bbc18273",
      "name": "create tender",
      "credentials": {
        "nocoDbApiToken": {
          "id": "tg1sd8Mux2yjJLx7",
          "name": "NocoDB"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "58d589f8-d304-41f1-9541-30806e496b6a",
              "name": "parsed",
              "value": "={{ $node[\"update parameters\"].json }}",
              "type": "object"
            },
            {
              "id": "ca4b147d-78da-4916-be3d-70947e05fd7d",
              "name": "tender_created",
              "value": "={{ $(\"create tender\").isExecuted }}",
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        832,
        224
      ],
      "id": "8102a79e-9f40-4ec9-ae00-8bccde2a8c49",
      "name": "output"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$vars.nocodb_url}}api/v2/tables/m72mqad09x2x46l/links/c1tidk3bg2ipjau/records/{{ $json.Id }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "nocoDbApiToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "=[{{ $('start').item.json.cs_id }}]",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1072,
        -64
      ],
      "id": "66855f63-f1fe-46c7-b6b4-c63e3452e6e5",
      "name": "link",
      "credentials": {
        "nocoDbApiToken": {
          "id": "tg1sd8Mux2yjJLx7",
          "name": "NocoDB"
        }
      }
    }
  ],
  "connections": {
    "start": {
      "main": [
        [
          {
            "node": "get cs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get call": {
      "main": [
        [
          {
            "node": "run?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculator": {
      "ai_tool": [
        [
          {
            "node": "loads_per_week",
            "type": "ai_tool",
            "index": 0
          },
          {
            "node": "interest_level",
            "type": "ai_tool",
            "index": 0
          },
          {
            "node": "tender_detect",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "loads_per_week parser": {
      "ai_outputParser": [
        [
          {
            "node": "loads_per_week",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "get cs": {
      "main": [
        [
          {
            "node": "get call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "run?": {
      "main": [
        [
          {
            "node": "loads_per_week",
            "type": "main",
            "index": 0
          },
          {
            "node": "interest_level",
            "type": "main",
            "index": 0
          },
          {
            "node": "destinations",
            "type": "main",
            "index": 0
          },
          {
            "node": "freight_org",
            "type": "main",
            "index": 0
          },
          {
            "node": "tender_detect",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "tender_detect parser": {
      "ai_outputParser": [
        [
          {
            "node": "tender_detect",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Think": {
      "ai_tool": [
        [
          {
            "node": "tender_detect",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "4.1-mini": {
      "ai_languageModel": [
        [
          {
            "node": "loads_per_week",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "loads_per_week parser",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "interest_level",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "destinations",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "freight_org",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "tender_detect parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "4.1": {
      "ai_languageModel": [
        [
          {
            "node": "tender_detect",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "loads_per_week": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "interest_level": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "destinations": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "tender_detect": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "freight_org": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "to beauty",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "to beauty": {
      "main": [
        [
          {
            "node": "update parameters",
            "type": "main",
            "index": 0
          },
          {
            "node": "create tender?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "create tender?": {
      "main": [
        [
          {
            "node": "create tender",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "update parameters": {
      "main": [
        [
          {
            "node": "output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "create tender": {
      "main": [
        [
          {
            "node": "link",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "agw6jjdVg6yAawFi"
  },
  "triggerCount": 0,
  "versionId": "32a54301-1475-4eed-bf14-2b3612972111",
  "owner": {
    "type": "personal",
    "projectId": "I8ZweZXokOc0zbYb",
    "projectName": "BSU Agency <info@brilliantseedup.com>",
    "personalEmail": "info@brilliantseedup.com"
  },
  "parentFolderId": "ldWFZ7Y31LSfJYne",
  "isArchived": false
}